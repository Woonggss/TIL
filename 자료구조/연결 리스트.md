# CHATPER 2. 연결 리스트

리스트와 관련된 기본 연산에는 항목을 찾는 탐색, 새로운 항목을 추가하는 삽입, 항목을 제거하는 삭제 연산이 있다.

이번 챕터에서는 다양한 연결리스트들을 구현해보고, 각각의 장단점을 살펴본다.


## 2.1. 단순연결리스트

단순연결리스트는 동적 메모리 할당을 이용해, 노드들을 한 방향으로 연결하여 리스트를 구현하는 자료구조이다.

![image](https://user-images.githubusercontent.com/88834958/139363854-a6a51ab8-ae77-4b5f-81ad-6f3823efbec3.png)

동적 메모리 할당을 받아 노드를 저장하고, 노드는 레퍼런스를 이용하여 다음 노드를 가리키도록 만들어 노드를 한 줄로 연결시킨다.

### 연산 별 수행 시간의 비교

* 탐색

연결 리스트의 노드들을 처음부터 순차적으로 방문해야 하므로, O(N)시간이 소요된다.(N = 노드 수)

* 삽입, 삭제

각각 1개의 레퍼런스를 갱신하므로, O(1)시간이 걸린다. 특정 Node의 레퍼런스가 주어진 경우에 그렇고, 만약 레퍼런스가 주어지지 않으면 그 Node를 찾기 위해서 탐색을 돌려야 하므로 O(N)시간이 소요될 수 있다.


단순연결리스트는 스택과 큐, 해싱의 체이닝에 사용되며, 트리도 단순연결리스트를 확장시킨 개념이다.


## 2.2. 이중연결리스트

이중연결리스트는 각 노드가 두 개의 레퍼런스를 가지고 각각 이전 노드와 다음 노드를 가리키는 연결리스트이다.

* 맨 처음 실행 시

![image](https://user-images.githubusercontent.com/88834958/139364780-a6620913-6aec-4d4f-8d02-5d97000c6fa0.png)

DList 객체를 생성하면, 2개의 'dummy' 노드를 생성하고 이 두 노드에는 실제 항목을 저장하지 않는다.




* 삽입

![image](https://user-images.githubusercontent.com/88834958/139364812-6076d566-6182-48ea-9a2a-24033638ca4c.png)

그림의 넘버링에 맞춰 설명하면 다음과 같다.

1) 먼저 t를 생성해서, p의 이전 노드로 지정한다.(기존 상태)
4) n이라는 새로운 노드를 생성하는데, 이 때 n = self.Node(item,t(2),p(3))으로 지정해서 만든다.
5) p의 이전 노드는 n이라고 연결 수정해준다.
6) t의 이후 노드는 n이라고 연결 수정해준다.


위 코드는 insert_before(앞 쪽 삽입)의 예시를 든 것이며, insert_after(뒤 쪽 삽입)은 1)에서 t를 p의 이후 노드로 지정하고 5), 6) 에서도 마찬가지로 연결 수정을 잘 해주면 된다.




* 삭제

![image](https://user-images.githubusercontent.com/88834958/139365598-d7579534-bd75-4b77-aacb-fd9c22cb2a12.png)

X를 지우는 과정이다.

1) X가 f의 앞에 있음을 의미한다.
2) r이 x에 뒤에 있음을 의미한다. 1,2는 기존 상태이다.
3) f 뒤에 r이 있음을 의미한다.
4) r의 전에 f가 있음을 의미한다. 3,4는 X를 제거하고 r과 f를 이어 붙이는 단계라고 보면 된다.


### 연산 별 수행시간의 비교

이중연결리스트의 삽입, 삭제 연산은 각각 O(1)개의 레퍼런스만을 갱신하므로, O(1)시간에 수행된다. 

탐색은 단순연결리스트와 마찬가지로 head or tail로부터 순차 탐색해야 하므로 O(N) 시간이 소요된다.


이중연결리스트는 3장의 데크 자료구조를 구현하는 데 사용되며, 이항 힙이나 피보나치 힙과 같은 우선순위 큐를 구현하는 데에도 부분적으로 사용된다.


## 2.3. 원형연결리스트

원형연결리스트는 마지막 노드가 첫 노드와 연결된 단순연결리스트이다.

* 원형연결리스트의 장점과 단점

마지막 노드와 첫 번째 노드를 O(1) 시간에 방문할 수 있는 장점을 가진다.


리스트가 empty가 아니면 어떤 노드도 None을 가지고 있지 않으므로 프로그램에서 None 조건을 검사하지 않아도 된다.


그러나 반대 방향으로 노드들을 방문하기 쉽지 않으며, 무한 루프가 발생할 수 있음에 유의할 필요가 있다.


