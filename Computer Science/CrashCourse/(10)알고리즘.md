알고리즘은 컴퓨터가 문제를 해결하는 방식이다. 다양한 알고리즘이 있는데, 여기서는 정렬과 그래픽 탐색 알고리즘을 다루고 있다. 정렬은 다시 선택 정렬과 합병 정렬로 나뉘고, 그래픽 탐색은 Brute Force 방식과 Dijkstra의 알고리즘 방식으로 나뉜다.


### 정렬


#### 선택 정렬


선택 정렬은 처음부터 숫자를 탐색하면서, 가장 작은 것, 그 다음으로 작은 것, 3번째로 작은 것, ... , 순서대로 위에서부터 차곡차곡 쌓아 내려가는 방법이다. N개의 항목을 정렬하고 싶다면, N번 탐색을 반복해야 할 것이다. 그리고 각 반복마다 N회 반복을 하므로, 시간 복잡도는 Big-Oh(N^2)로 표기할 수 있을 것이다.


#### 합병 정렬


합병 정렬은 선택 정렬의 시간 복잡도를 줄여주는 방법이다. 합병 정렬은 좀 더 과정이 복잡하다. 말로 풀어서만 설명하면 꼬일 수가 있으므로, 번호를 붙여서 표기해보겠다. 예시에서는 8개의 숫자를 정렬하는 방법에 대해 논하고 있다.

1) 배열 크기가 1보다 큰지 확인한다.
2) 배열 크기가 1이 될 때까지 반으로 쪼개준다.
3) 각 배열끼리 비교해서, (small, big)인 4개의 쌍을 만들어준다.
4) 4개의 쌍을 2쌍, 2쌍으로 나누어서 순서대로 정렬한다.(숫자 4개/ 숫자 4개)
5) 마지막으로 2개의 쌍을 또 비교해서 최종적인 정렬 리스트를 만들어준다.

2번 과정은 배열을 쪼개는 과정이고, 3~5번 과정은 배열을 원래 크기로 합치는 과정이다. 합병 정렬의 시간 복잡도는 Big-Oh(NlogN)으로 나타나는데, N은 각 단계에서 비교하는 횟수를 의미하고 log(2)N은 병합 단계의 수를 의미한다. 그러니까 8->4->2->1로 3번 쪼갰기 때문에(log(2)8), 병합도 3번 해주어야 할 것이다.


### 그래픽 탐색


#### BRUTE FORCE


가장 단순한 방법으로, 모든 경로를 조사해서 각 비용을 계산하는 것이다. 이 경우에 시간 복잡도는 Big-Oh(N!)으로 나타난다.


#### Dijkstra의 알고리즘


1) 출발 노드 = 0
2) 각 노드에 갈 때마다 들어가는 Total Cost를 기록한다.
3) 최소 비용 노드에서, 연결된 노드로 이동한다.
4) 만약 비용이 기록되지 않은 노드라면 비용을 업데이트하고, 비용이 기록된 노드라면 기존 비용과 크기를 비교해서 더 작은 경우에만 비용을 업데이트한다.

2 ~ 4의 과정을 반복한다. 이 때 시간 복잡도는 Big-Oh(N^2)가 된다. 이후 개선된 Dijkstra의 알고리즘이 등장했는데, 이것의 시간 복잡도는 Big-Oh(NlogN + 1)이다.






